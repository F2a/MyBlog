<!DOCTYPE html>
<html lang="">
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="JavaScript基础原理（一）">




  <meta name="keywords" content="JS原理,">





  <link rel="alternate" href="/blog/default" title="银の龙の背に乗って">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=1.1">



<link rel="canonical" href="https://f2a.github.io/blog/2018/02/05/javaScript01/">


<meta name="description" content="1. 七种内置类型基本类型： null，undefined，boolean，number（浮点类型），string，symbol（es6）。 对象：Object。 类型转换 typeof:  12345678910typeof 1 // &amp;apos;number&amp;apos;typeof &amp;apos;1&amp;apos; // &amp;apos;string&amp;apos;typeof undefined // &amp;">
<meta name="keywords" content="JS原理">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础原理（一）">
<meta property="og:url" content="https://f2a.github.io/blog/2018/02/05/javaScript01/index.html">
<meta property="og:site_name" content="银の龙の背に乗って">
<meta property="og:description" content="1. 七种内置类型基本类型： null，undefined，boolean，number（浮点类型），string，symbol（es6）。 对象：Object。 类型转换 typeof:  12345678910typeof 1 // &amp;apos;number&amp;apos;typeof &amp;apos;1&amp;apos; // &amp;apos;string&amp;apos;typeof undefined // &amp;">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2018-11-22T06:19:36.613Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript基础原理（一）">
<meta name="twitter:description" content="1. 七种内置类型基本类型： null，undefined，boolean，number（浮点类型），string，symbol（es6）。 对象：Object。 类型转换 typeof:  12345678910typeof 1 // &amp;apos;number&amp;apos;typeof &amp;apos;1&amp;apos; // &amp;apos;string&amp;apos;typeof undefined // &amp;">


<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> JavaScript基础原理（一） - 银の龙の背に乗って </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/blog/." class="logo">银の龙の背に乗って</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/blog/archives">
                            
                            
                                归档
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/blog/about">
                            
                            
                                关于
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          JavaScript基础原理（一）
        
      </h1>

      <time class="post-time">
          2月 05 2018
      </time>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-七种内置类型"><span class="toc-text">1. 七种内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四则运算"><span class="toc-text">四则运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冷知识"><span class="toc-text">冷知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-实例对象"><span class="toc-text">2. 实例对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new"><span class="toc-text">new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#冷知识-1"><span class="toc-text">冷知识</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-执行上下文"><span class="toc-text">3. 执行上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-VO-amp-AO"><span class="toc-text">属性 VO &amp; AO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-this-amp-作用域链"><span class="toc-text">属性 this&amp;作用域链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个面试题"><span class="toc-text">一个面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-深浅拷贝"><span class="toc-text">4. 深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#浅拷贝"><span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#深拷贝"><span class="toc-text">深拷贝</span></a></li></ol></li></ol>
    </div>
  </div>


    
            <div class="post-content">
            <h3 id="1-七种内置类型"><a href="#1-七种内置类型" class="headerlink" title="1. 七种内置类型"></a>1. 七种内置类型</h3><pre><code>基本类型： null，undefined，boolean，number（浮点类型），string，symbol（es6）。
对象：Object。
</code></pre><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>typeof:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typeof 1 // &apos;number&apos;</span><br><span class="line">typeof &apos;1&apos; // &apos;string&apos;</span><br><span class="line">typeof undefined // &apos;undefined&apos;</span><br><span class="line">typeof true // &apos;boolean&apos;</span><br><span class="line">typeof Symbol() // &apos;symbol&apos;</span><br><span class="line">typeof b // b 没有声明，但是还会显示 undefined</span><br><span class="line">typeof []  // &apos;object&apos;</span><br><span class="line">typeof &#123;&#125;  // &apos;object</span><br><span class="line">typeof null  // &apos;object&apos;</span><br><span class="line">typeof console.log // &apos;function&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>valueOf</p>
<p>  对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">    	return 0</span><br><span class="line">    toString() &#123;</span><br><span class="line">    return &apos;1&apos;;</span><br><span class="line">  &#125;,</span><br><span class="line">// Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">1 + a // =&gt; 3</span><br><span class="line">&apos;1&apos; + a // =&gt; &apos;12&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>比较运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果是对象，就通过 toPrimitive 转换对象</span><br><span class="line">如果是字符串，就通过 unicode 字符索引来比较</span><br></pre></td></tr></table></figure>
<h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><pre><code>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。
其他运算只要其中一方是数字，那么另一方就转为数字。
并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 + &apos;1&apos; // &apos;11&apos;</span><br><span class="line">2 * &apos;2&apos; // 4</span><br><span class="line">[1, 2] + [2, 1] // &apos;1,22,1&apos;</span><br><span class="line">// [1, 2].toString() -&gt; &apos;1,2&apos;</span><br><span class="line">// [2, 1].toString() -&gt; &apos;2,1&apos;</span><br><span class="line">// &apos;1,2&apos; + &apos;2,1&apos; = &apos;1,22,1&apos;</span><br><span class="line"></span><br><span class="line">// 对于加号需要注意这个表达式 &apos;a&apos; + + &apos;b&apos;</span><br><span class="line">&apos;a&apos; + + &apos;b&apos; // -&gt; &quot;aNaN&quot;</span><br><span class="line">// 因为 + &apos;b&apos; -&gt; NaN</span><br></pre></td></tr></table></figure>
<h4 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h4><ul>
<li>NaN 属于 number 类型，并且 NaN 不等于自身。</li>
<li>undefined 不是保留字，能够在低版本浏览器被赋值 let undefined = 1</li>
</ul>
<h3 id="2-实例对象"><a href="#2-实例对象" class="headerlink" title="2. 实例对象"></a>2. 实例对象</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><ul>
<li>在调用 new 的过程中会发生以上四件事情</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 新生成了一个对象</span><br><span class="line">// 链接到原型</span><br><span class="line">// 绑定 this</span><br><span class="line">// 返回新对象</span><br><span class="line"></span><br><span class="line">function new() &#123;</span><br><span class="line">    // 创建一个空的对象</span><br><span class="line">    let obj = new Object()</span><br><span class="line">    // 获得构造函数</span><br><span class="line">    let Con = [].shift.call(arguments)</span><br><span class="line">    // 链接到原型</span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    // 绑定 this，执行构造函数</span><br><span class="line">    let result = Con.apply(obj, arguments)</span><br><span class="line">    // 确保 new 出来的是个对象</span><br><span class="line">    return typeof result === &apos;object&apos; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行优先级</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = function () &#123;</span><br><span class="line">    console.log(&apos;1&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = function () &#123;</span><br><span class="line">    console.log(&apos;2&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   // -&gt; 1</span><br><span class="line">new Foo().getName(); // -&gt; 2</span><br><span class="line"></span><br><span class="line">// new Foo() 的优先级大于 new Foo</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new (Foo.getName());</span><br><span class="line">(new Foo()).getName();</span><br><span class="line"></span><br><span class="line">// 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；</span><br><span class="line">// 对于后者来说，先执行 new Foo() 产生了一个实例，</span><br><span class="line">// 然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li>通用规则<br>new有最高优先级，利用 call，apply，bind 改变 this，优先级仅次于 new。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 1</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line">// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span><br><span class="line"></span><br><span class="line">// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span><br><span class="line">var c = new foo()</span><br><span class="line">c.a = 3</span><br><span class="line">console.log(c.a)</span><br><span class="line"></span><br><span class="line">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。</li>
</ul>
<h4 id="冷知识-1"><a href="#冷知识-1" class="headerlink" title="冷知识"></a>冷知识</h4><ul>
<li>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</li>
</ul>
<h3 id="3-执行上下文"><a href="#3-执行上下文" class="headerlink" title="3. 执行上下文"></a>3. 执行上下文</h3><ol>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li>eval 执行上下文</li>
</ol>
<h4 id="属性-VO-amp-AO"><a href="#属性-VO-amp-AO" class="headerlink" title="属性 VO &amp; AO"></a>属性 VO &amp; AO</h4><p>变量对象 (缩写为VO)就是与执行上下文相关的对象，它存储下列内容：</p>
<ol>
<li>变量 (var, VariableDeclaration);</li>
<li>函数声明 (FunctionDeclaration, 缩写为FD);</li>
<li>函数的形参</li>
</ol>
<ul>
<li>只有全局上下文的变量对象允许通过VO的属性名称间接访问(因为在全局上下文里，全局对象自身就是一个VO(稍后会详细介绍)。在其它上下文中是不可能直接访问到VO的，因为变量对象完全是实现机制内部的事情。当我们声明一个变量或一个函数的时候，同时还用变量的名称和值，在VO里创建了一个新的属性。</li>
</ul>
<p>激活对象是函数上下文里的激活对象AO中的内部对象，它包括下列属性：</p>
<ol>
<li>callee — 指向当前函数的引用；</li>
<li>length —真正传递的参数的个数；</li>
<li>properties-indexes(字符串类型的整数)</li>
</ol>
<ul>
<li>属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。(译者注：共享与不共享的区别可以对比理解为引用传递与值传递的区别)</li>
</ul>
<h4 id="属性-this-amp-作用域链"><a href="#属性-this-amp-作用域链" class="headerlink" title="属性 this&amp;作用域链"></a>属性 this&amp;作用域链</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b() // call b</span><br><span class="line">console.log(a) // undefined</span><br><span class="line"></span><br><span class="line">var a = &apos;Hello world&apos;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&apos;call b&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>以上众所周知因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p>
</li>
<li><p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b() // call b second</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&apos;call b fist&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&apos;call b second&apos;)</span><br><span class="line">&#125;</span><br><span class="line">var b = &apos;Hello world&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于非匿名的立即执行函数需要注意以下一点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1</span><br><span class="line">(function foo() &#123;</span><br><span class="line">    foo = 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;()) // -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;  打印出立即执行函数自身</span><br><span class="line">// 内部独立作用域，不会影响外部的值</span><br></pre></td></tr></table></figure>
<h4 id="一个面试题"><a href="#一个面试题" class="headerlink" title="一个面试题"></a>一个面试题</h4><p>循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for ( var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br><span class="line">// 因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。</span><br></pre></td></tr></table></figure>
<p>解决办法</p>
<p>第一种使用闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;, j * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种就是使用 setTimeout 的第三个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for ( var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	setTimeout( function timer(j) &#123;</span><br><span class="line">		console.log( j );</span><br><span class="line">	&#125;, i*1000, i);</span><br><span class="line">&#125;</span><br><span class="line">// 第三个参数及以后的参数都可以作为func函数的参数，例：</span><br><span class="line">function a(x, y) &#123;</span><br><span class="line">    console.log(x, y) // 2 3</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(a, 1000, 2, 3)</span><br></pre></td></tr></table></figure>
<p>第三种就是使用 let 定义 i 了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ( let i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于 let 来说，他会创建一个块级作用域，相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123; // 形成块级作用域</span><br><span class="line">  let i = 0</span><br><span class="line">  &#123;</span><br><span class="line">    let ii = i</span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">        console.log( i );</span><br><span class="line">    &#125;, i*1000 );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-深浅拷贝"><a href="#4-深浅拷贝" class="headerlink" title="4. 深浅拷贝"></a>4. 深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>通过 Object.assign</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b = Object.assign(&#123;&#125;, a)</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 展开运算符（…）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;...a&#125;</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>
<ul>
<li>弊端：浅拷贝只解决了第一层的问题。如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>通过 JSON.parse(JSON.stringify(object))</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: &apos;FE&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = JSON.parse(JSON.stringify(a))</span><br><span class="line">a.jobs.first = &apos;native&apos;</span><br><span class="line">console.log(b.jobs.first) // FE</span><br></pre></td></tr></table></figure>
<p>该方法也是有局限性的：会忽略 undefined，忽略函数，不能解决循环引用的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2,</span><br><span class="line">    d: 3,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj)) // 会报错</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果你的数据中含有以上三种情况下，通过  lodash 的深拷贝函数，或者使用 MessageChannel</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; = new MessageChannel();</span><br><span class="line">    port2.onmessage = ev =&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;a: 1, b: &#123;</span><br><span class="line">    c: b</span><br><span class="line">&#125;&#125;</span><br><span class="line">// 注意该方法是异步的</span><br><span class="line">// 可以处理 undefined 和循环引用对象</span><br><span class="line">const clone = await structuralClone(obj);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>整理自面谱 InterviewMap</p>
</blockquote>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/blog/tags/JS原理/">JS原理</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/blog/2018/02/18/javaScript02/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">JavaScript基础原理（二）</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/blog/2017/11/20/interviewee01/">
        <span class="next-text nav-default">面试知识点汇总</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2018
    <span class="footer-author">FangR.</span>
    <span class="power-by">
        由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a> 强力驱动
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/blog/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/blog/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/blog/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
